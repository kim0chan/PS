# 11700 ~ 11799


## 11720 : 숫자의 합

## 11721 : 열 개씩 끊어 출력하기

## 11724 : 연결 요소의 개수
그래프 순회 문제. (BFS, DFS)

## 11725 : 트리의 부모 찾기
('23. 3. 27.) 다시 풀었음.

## 11726 : 2×n 타일링
DP  
관련 문제 : [11727](https://www.boj.kr/11727) 2×n 타일링

## 11727 : 2×n 타일링
관련 문제 : [11726](https://www.boj.kr/11726) 2×n 타일링

## 11728 : 배열 합치기
STL sort 함수 썼는데 merge sort 직접 짜서 업데이트 하도록 해요('23. 2. 28.)

## 11779 : 최소비용 구하기 2
데이크스트라(다익스트라) 문제이다.  
경로를 복원하고, 경로를 출력해야한다.  
정답 출력에 `vector`를 사용했고, `reverse(v.begin(), v.end());`를 이용하여 순서를 뒤집어줄 수 있었다..

## 11780 : 플로이드 2
관련 문제 : [11404](https://boj.kr/11404) 플로이드  
플로이드 알고리즘으로 풀어준다.  
플로이드 알고리즘을 이용한 **경로 복원**이 핵심인 문제인데, `nextmat`이라는 배열을 정의했다.  
`nextmat[i][j]`에는 정점 `i`에서 정점 `j`로 갈 때 이동해야 할 다음 정점을 저장되어 있다.  
만약 `i`에서 `j`로 갈 때 `k`를 경유하는 것이 더 경제적이라면, `d[i][j] = d[i][k] + d[k][j]`로 업데이트가 될 것이다.  
이 때 `nextmat[i][j]`를 `nextmat[i][k]`로 업데이트한다.  
정답의 출력은 `solve`라는 `vector`를 선언하여 경로에 있는 노드들을 저장한 뒤에 출력하는 방식으로 이루어진다.  
초기화를 위해 `vector`의 멤버 함수인 `solve.clear()`를 사용했다. 이것은 `vector`의 `size`를 `0`으로 한다.

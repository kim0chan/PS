# 1900 ~ 1999


## 1904 : 01타일
DP

## 1912 : 연속합
('23. 10. 18.) 다시 풀엇어용
```cpp
#include <bits/stdc++.h>
using namespace std;

int main(void) {
	cin.sync_with_stdio(0);
	cin.tie(0);

	int n;
	cin >> n;
	vector<int> arr(n);
	vector<int> dp(n);

	for (int i = 0; i < n; i++) {
		cin >> arr[i];
	}

	dp[n - 1] = arr[n - 1];
	for (int i = n - 2; i >= 0; i--) {
		if(dp[i + 1] > 0) {
			dp[i] = arr[i] + dp[i + 1];
		}
		else {
			dp[i] = arr[i];
		}
	}

	cout << *max_element(dp.begin(), dp.end()) << '\n';
}
```

## 1915 : 가장 큰 정사각형
DP로 풀었다.  
사실 인터넷 상의 풀이와 해설에 전적으로 의존하여 풀었다.  
DP 값을 정사각형에서 가장 우측 하단에 저장하는 발상까지는 떠올랐는데 그 후로는 전혀 모르겠더라고  
코드가 엄청 깔끔하다. 대단하다.

## 1916 : 최소비용 구하기
다익스트라 알고리즘

## 1920 : 수 찾기
('23. 3. 18.) 이분 탐색 함수 구현하여 다시 풀었다.
> **ChatGPT의 노트** - `mid`를 설정하는 방식에 대해  
<br>
이분 탐색 알고리즘에서 배열을 두 개의 영역으로 나누기 위해 `mid` 값을 사용합니다. 이 때, `mid` 값을 `(st + en) / 2`와 같이 설정하면, `st`와 `en`이 서로 인접해 있을 때, `mid` 값이 `st`와 같아질 수 있습니다. 이 경우, `st`와 `en`이 동일한 값이고 그 값이 찾고자 하는 값과 다르다면, 정확한 답을 찾지 못하고 반복문을 빠져나오게 됩니다. 즉, 최종적으로 찾고자 하는 값이 남아있는 경우, 알고리즘이 제대로 작동하지 않을 수 있습니다.  
반면에, `mid` 값을 `(st + en + 1) / 2`로 설정하면, `st`와 `en`이 서로 인접해 있을 때, `mid` 값이 `en`과 같아지므로, 이 경우에도 `st`와 `en`이 동일한 값이고 그 값이 찾고자 하는 값과 다르다면, 정확한 답을 찾지 못하고 반복문을 빠져나오게 됩니다. 하지만 이 방법으로 `mid` 값을 설정하는 경우, `st`와 `en`이 인접한 경우에는 항상 두 번째 영역에 `mid` 값이 포함되도록 보장됩니다. 따라서, 최종적으로 찾고자 하는 값이 남아있는 경우에도 알고리즘이 정확한 답을 찾을 수 있습니다.

## 1926 : 그림

## 1927 : 최소 힙
관련 문제 : [11279](https://www.acmicpc.net/problem/11279) 최대 힙

## 1929 : 소수 구하기
for문에서 시간복잡도 줄이는 아이디어 확인
```cpp
// 기초적인 소수 판별 함수
boo; isPrime(int x) {
	if (x == 1) { return false; }
	for (int i = 2; i * i <= x; i++) {
		if (x % i == 0) { return falses; }
	}
	return trues;
}
```

**('23. 2. 17.)** 에라토스테네스의 체를 공부하여 업데이트함.
```cpp
vector<bool> sieve(M + 1, true);
sieve[1] = false;
for (int i = 2; i * i <= M; i++) {
	if (!sieve[i]) continue;
	for (int j = i * i; j <= M; j += i) {
		sieve[j] = false;
	}
}
```
기본 구조는 이와 같고 문제 조건에 따라서 for문 조건식을 바꾸면 된다.

## 1931 : 회의실 배정
알고리즘 수업에서 배운 알고리즘

## 1932 : 정수 삼각형
다이나믹 프로그래밍

## 1946 : 신입 사원
아이디어가 중요하다.  
서류 순위로 일단 정렬하고 나면 면접 순위가 밀리는 순간 탈락이니까  
그런 식으로 구현하였다.
`pair<int, int>`형 vector container을 정렬하는데,  
`v.rbegin()`, `v.rend()`를 이용하고 `back`을 참조하며 `pop_back`을 했다.  
prqueue를 쓸 수 있을 것 같다.

## 1956 : 운동
플로이드를 쓰는 문제인데  
여태껏 adjmatrix를 INF로 초기화 한 뒤 사용했는데.  
그냥 0으로 초기화 된 상태에서 i>k, k>j가 있는지를 판별하는 방식이 유효한 것 같다.  
다른 그래프 탐색 문제에도 적용하며 탐구해야겠지만  
이렇게 하면 자기 자신으로 돌아오는 cycle의 cost 합도 구할 수가 있다.  
관련 문제: [11404](https://www.acmicpc.net/problem/11404) 플로이드  
근데 여기에는 적용이 안되는 것으로 보여 코드를 잘 살펴봐야 할 것 같다.

## 1966 : 프린터 큐

## 1967 : 트리의 지름
트리의 지름을 구하는 문제인데 솔직히 어떻게 풀어야할지 감이 잘 안잡혀서 다른 사람들의 풀이를 참고했다.  
기본 아이디어는 다음과 같다.  
1. 그래프 내에서 서로 가장 멀리 위치한 두 노드가 '트리의 지름' 양 끝에 위치한다.
2. 어떤 정점에서 출발해도 가장 멀리 있는 노드는 1에서 말한 두 노드 중 하나일 것이다.
3. **한 정점에서 dfs를 수행하여 가장 멀리 있는 지점을 찾은 후에 그 지점에서 dfs를 수행해 가장 멀리 있는 지점과의 거리를 구한다.**

## 1976 : 여행 가자
플로이드 알고리즘 기반으로 풀었다.  
근데 연결 여부만 확인하면 되어서 i>k, k>j가 연결되어 있다면 i>j도 연결시키는 식으로 구현했다.  
`i==j`일 때 i>j를 연결시키는 코드 한 줄을 추가했는데 이걸 안하면 채점 80%에서 오답이 떠 버린다.  
왜인지는 잘 모르겠다.

## 1978 : 소수 찾기

## 1991 : 트리 순회
preorder, inorder, postorder traversal  
('23. 3. 27) 다시 풀었음.



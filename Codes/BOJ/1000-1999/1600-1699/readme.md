# 1600 ~ 1699


## 1620 : 나는야 포켓몬 마스터 이다솜
해쉬(`unordered_map`)를 이용해서 풀었다.  
눈여겨볼 점은 `unordered_map` STL의 사용과  
`key`, `value`를 어떻게 관리해야하는지  
그리고 문자를 입력받아 숫자인지 판독하는 `isdigit` 함수와 문자열 > 정수 형변환을 위한 `stoi` 함수의 이용

## 1629 : 곱셈
재귀로 구현. 나중에 한 번 보삼

## 1644 : 소수의 연속합
그냥 구현했는데 투 포인터로 풀 수 있다고 하네? 다시 풀어보자  
채점할 때 방식으로 1380ms가 걸리고 투 포인터를 쓴 예제는 32ms가 걸린다고 하네

**('23. 2. 16.)** 제출번호 `55933539`: 투 포인터 방식으로 풀었는데, 96% 정답이 나오고 `OutOfBounds` 에러로 틀려버린다. 여러 시도를 해 보았는데 에러를 해결할 수가 없다. 에러를 해결하면 readme 수정 바람.  
그런데 실행 속도는 그대로인 것 같다. 아마 소수를 구하는 방식이 비효율적인 것 같다. [예시 코드](http://boj.kr/d1ba3e452d8842d7a9e56640231e25f5)에서 소수를 구하는 방식을 체크해보자.

    test case를 체크했더니 N이 1일 때 문제가 발생하는 것으로 보인다. 예시 코드와 내 코드의 차이점을 찾아보자..

## 1647 : 도시 분할 계획
MST(최소 신장 트리) 문제로, 프림 알고리즘을 이용하여 풀었다.  
문제는 마을을 두 부분으로 분할한다는 점인데, 잘 생각해 보면 전체 MST를 구하고 나서  
MST에 속한 간선 중 가장 cost가 높은 것을 쳐내면 두 그래프를 최소 신장 트리로 나눌 수 있다는 점을 발견할 수 있다.

## 1654 : 랜선 자르기
parametric search를 이용하여 풀었다.  
`long long` type을 쓴 이유는 `(st+en+1)/2` 할 때 int overflow가 발생할 수도 있어서이다.  
바킹독님의 풀이를 많이 참조하여 풀었다.  
유사 문제들을 많이 풀어보면 될 것 같다.

## 1655 : 가운데를 말해요
두 개의 priority queue(`maxpq`, `minpq`)를 이용해서 풀었다.  
원소가 입력될 때마다 다음 두 가지 조건을 만족하게 enqueue한다.
> 1. 최대합의 크기와 최소합의 크기 차이는 1보다 크지 않게 한다.  
> 편의를 위해 최대합이 항상 더 큰 크기를 갖는다.
> 2. 최대합의 원소들은 최소합의 모든 원소들보다 작다.  
> 중간값을 찾기 위해서이다. `top`끼리 비교하면 될 것이다.

그리고 매 iteration마다 `maxpq.top()`을 출력해준다.  
응용/변형 문제가 많을 것 같으니 주의 깊게 보자.  
[이 게시글](https://yabmoons.tistory.com/478)을 참고하여 풀었다.

## 1697 : 숨바꼭질
숨바꼭질 BFS 시리즈

# 1700 ~ 1799


## 1707 : 이분 그래프
노드 방문(BFS) 시 `visited`에 타입을 저장하고, 인접한 노드가 같은 타입을 갖는지 체크한다.  
인접한 두 노드가 같은 타입을 가지는 경우 Bipartite 하지 않다.  
BFS 과정에서 인접한 노드가 같은 타입을 갖는 경우를 식별하면 바로 `break`해서 출력부로 가는 [코드](https://www.acmicpc.net/source/67722426)를 만들었는데 오히려 시간이 더 오래걸린다. 왜 그럴까? `if`문에 따른 분기가 더 많아져서 그런건가?

## 1712 : 손익분기점

## 1717 : 집합의 표현
분리 집합을 이용하여 풀었다.  
`Union` 함수를 확립했다.

## 1715 : 카드 정렬하기
그리디, 우선순위 큐

## 1759 : 암호 만들기
백트래킹

## 1766 : 문제집
위상정렬에 `priority_queue`를 얹어 먹는 문제입니다.

## 1753 : 최단경로
다익스트라 문제고 처음 푸는 거라 풀이에 의존하여 풀었다.  
그런데 우선순위 큐 코드 내에 `next`, `cur`, `COST`, `DST` 부분이 서로 많이 헷갈려서  
복습을 많이 하면서 체화하는 것이 필요해 보인다.

## 1781 : 컵라면
그냥 `priority_queue`를 쓰게 되면 문제가 발생한다.  
데드라인|컵라면수
---|---
1|1
2|2
2|3

다음 경우를 생각해보자. 1일차에 1짜리 풀고 2일차에 3짜리 풀면 최대가 되는가?  
그렇지 않다. 1일차에 컵라면 2개를 주는 데드라인이 2인 문제를 푸는 것이 낫다.

그렇기 때문에 일단 pq를 데드라인 기준 오름차순, 컵라면 수 기준 내림차순으로 정렬하고, 정답 계산용 pq(`temp`)를 하나 더 선언한다.  
컵라면을 그리디하게 선택할 때마다 여기에 삽입한다.  
데드라인 기준으로 정렬한 것에서부터 선택을 해 삽입해 놓은 것이기 때문에, 그리고 문제를 푸는 데 걸리는 단위 시간이 1이기 때문에 `temp`에 있는 것들을 빼고 다른 것을 삽입해도 데드라인 영향 없다.

N부터 시작해서 N-1, N-2, ..., 1로 내려오면서 그리디하게 푸는 방법이 있는 것 같은데 나중에 생각해보자.

아 그리고 `priority_queue`의 제일 오른쪽 원소가 `top`인 것을 자꾸 까먹는데  
pq용 비교 함수 만드는 거랑 오른쪽으로 정렬하는 거 잊지 말자

# 11700 ~ 11799

## 11719 : 그대로 출력하기 2
입력 받아서 그대로 출력하는 쉬운 문제이다.  
다만 입력 문자열에 공백이 있다는 점에 유념해야 한다.
```cpp
#include <stdio.h>
 
 
int main(void)
{
	char a;
	
	while (scanf("%c",&a)!=EOF)
	{
		printf("%c",a);
	}
	return 0;
}
```
이렇게도 풀어낼 수 있다. 코테 수준에선 딱히 필요하지 않을 것 같은 테크닉이지만 ..

## 11720 : 숫자의 합

## 11721 : 열 개씩 끊어 출력하기

## 11724 : 연결 요소의 개수
그래프 순회 문제. (BFS, DFS)

## 11725 : 트리의 부모 찾기
('23. 3. 27.) 다시 풀었음.

## 11726 : 2×n 타일링
DP  
관련 문제 : [11727](https://www.boj.kr/11727) 2×n 타일링

## 11727 : 2×n 타일링
관련 문제 : [11726](https://www.boj.kr/11726) 2×n 타일링

## 11728 : 배열 합치기
STL sort 함수 썼는데 merge sort 직접 짜서 업데이트 하도록 해요('23. 2. 28.)

## 11779 : 최소비용 구하기 2
데이크스트라(다익스트라) 문제이다.  
경로를 복원하고, 경로를 출력해야한다.  
정답 출력에 `vector`를 사용했고, `reverse(v.begin(), v.end());`를 이용하여 순서를 뒤집어줄 수 있었다..

## 11780 : 플로이드 2
관련 문제 : [11404](https://boj.kr/11404) 플로이드  
플로이드 알고리즘으로 풀어준다.  
플로이드 알고리즘을 이용한 **경로 복원**이 핵심인 문제인데, `nextmat`이라는 배열을 정의했다.  
`nextmat[i][j]`에는 정점 `i`에서 정점 `j`로 갈 때 이동해야 할 다음 정점을 저장되어 있다.  
만약 `i`에서 `j`로 갈 때 `k`를 경유하는 것이 더 경제적이라면, `d[i][j] = d[i][k] + d[k][j]`로 업데이트가 될 것이다.  
이 때 `nextmat[i][j]`를 `nextmat[i][k]`로 업데이트한다.  
정답의 출력은 `solve`라는 `vector`를 선언하여 경로에 있는 노드들을 저장한 뒤에 출력하는 방식으로 이루어진다.  
초기화를 위해 `vector`의 멤버 함수인 `solve.clear()`를 사용했다. 이것은 `vector`의 `size`를 `0`으로 한다.

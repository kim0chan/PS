# 2200 ~ 2299


## 2217 : 로프
일단 각 로프가 견딜 수 있는 최대 하중을 내림차순으로 정렬하고,  
병렬 연결된 로프들이 견딜 수 있는 무게를 계산하여 `max` 값을 greedy하게 업데이트했다.

## 2230 : 수 고르기
for문을 돌면서, `A[i] + M`에 대해 `lower_bound` 값을 구하여 `min` 값을 업데이트 하는 방식으로 풀었다.  
`lower_bound()` 함수는 주소값을 반환하는데, 배열의 첫 번째 주소를 빼 주면 `idx`를 구할 수 있다.  
찾고자 하는 값이 없다면 배열의 바깥 주소를 반환하기 때문에 이를 이용하였다.  
O(lg n)의 시간복잡도를 가지고 있기 때문에 잘 알아두면 활용성이 좋을 것 같다.  

※ 투 포인터를 이용하여도 풀 수 있다고 한다. 이를 이용하여 다시 풀어볼 예정이다.  
[투 포인터 풀이](https://www.acmicpc.net/source/57703682)

## 2240 : 자두나무
DP로 해결했다.  
자두 나무가 2개 뿐이기 때문에, 자리를 바꾼 횟수를 이용하여 현재 위치를 구할 수 있다.

## 2250 : 트리의 높이와 너비
이진트리 문제이다.  
중위 순회를 하면 해당 노드가 어느 열에 위치하는지를 특정할 수 있고, 각 `depth`에서 왼쪽 열과 오른쪽 열의 위치를 저장할 수 있다.  
저장해 놓은 값을 통해서 출력한다.

## 2252 : 줄 세우기
위상정렬 문제이다.  
기본적인 코드가 있으니 비슷한 문제를 풀 때 구조를 참고합시다.

## 2295 : 세 수의 합 (★)
바킹독 알고리즘 강의를 참고하여 풀었다.  
우선 집합(배열) `a`에 수들을 모두 입력받고, `a[i] + a[j] + a[k] = a[l]`을 만족하는 `l` 중에서 제일 큰 `a[l]`을 출력하는 문제이다.  
$O(N^4)$ 풀이가 직관적이지만, 그러면 시간 초과가 나기 때문에 다른 방법을 고려해야한다.  
$O(N^2 \lg N)$ 풀이는, 우선 새로운 배열 `added`를 만들어 `i`, `j` 2중 `for`문을 돌아서 `a[i]`와 `a[j]`의 합을 저장한 후에, `a[l] - a[k]`가 배열 `added`에 있는지 이분탐색을 하는 방법이다.  

코드 품질이 우수하니 자세한 것은 코드를 확인합시다 👀  
>**뭔가 2개를 묶거나 어느 한 쪽의 값을 이분탐색으로 찾아서 시간복잡도를 낮추는 아이디어는 이분탐색 응용 문제에서 핵심적으로 나오는 것이니 잘 알아둡시다.**

# 2000 ~ 2099


## 2003 : 수들의 합 2
투 포인터 이용했다  
`while`문 안에서 `if`문 순서를 [1644](https://boj.kr/1644)(소수의 연속합)이랑 왜 다르게 해야 돌아가는지 잘 모르겠다.  
계속 생각해봤는데 잘 모르겠다..  
아마 1644는 배열이 오름차순으로 정렬되어 있음이 보장되서 그런건가?  
그래도 이해가 잘 안간다 ..

## 2056 : 작업
위상 정렬을 이용해서 풀었다.  
인터넷의 풀이와는 다른 풀이를 고안해서 풀었다.  
`priority_queue`의 비교함수를 정의해서 사용하는 방법과 그 때 규칙을 잘 눈여겨보면 좋다.

## 2075 : N번째 큰수
`priority_queue`를 이용하여 풀고자 했는데 그냥 간단하게 생각해서 최대 힙을 썼더니 문제의 메모리 제한이 꽤나 빡빡해서 메모리 초과로 오답 판정을 받았다.  
발상의 전환으로 최소 힙을 사용하여 `N`개의 가장 큰 원소들을 저장 및 유지하는 식으로 구현했다.  
최소 힙을 사용하기 위해서는 `priority_queue<int, vector<int>, greater<int>>`와 같이 선언하면 된다.  
이러한 발상을 떠올리는 것이 중요할 것 같다..
